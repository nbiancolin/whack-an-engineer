module vgaHelper(iResetn, hhSelect, gameState,, moleHit clk, oX, oY, oColour, oPlot, oDone);
    parameter X_SCREEN_PIXELS = 8'd160;
    parameter Y_SCREEN_PIXELS = 7'd120;
    parameter CLOCK_FREQ = 13'd50000000; //LATER match this with board freq
    input iResetn, clk, moleHit;  //(iresetn is [0])
    //moleHit goes to 1 when a mole is hit (handle in 'GAME')
    input [4:0] hhSelect; //Also one-hot encoding (switches SW[4:0])

    output reg [7:0] oX; //coords that are being written
    output reg [6:0] oY;
    output reg [2:0] oColour;
    output reg oPlot, oDone;

	localparam	X_HH = 8'd30,
				Y_HH = 7'd20,
				//Hard Hat top starting coords (going ccw)
				//ONE: 
				X_1 = 47,
				Y_1 = 15,
				//TWO:
				X_2 = 97,
				Y_2 = 31,
				//THREE:
				X_3 = 126,
				Y_3 = 63,
				//FOUR:
				X_4 = 67,
				Y_4 = 82,
				//FIVE: 
				X_5 = 10,
				Y_5 = 53;


    localparam  P_RST       = 3'd0,     //draws over initial screen (from mif or with plot algo) (should also reset ram ??)
                RST         = 3'd1,     //waiting for input to start game
                P_GAME      = 3'd2,     //plots full screen from ram 
                GAME        = 3'd3,     //waits for input
                W_RAM       = 3'd4;     //writes to ram
                P_GAME_OVER = 3'd5;     //plots the game over
                GAME_OVER   = 3'd6;     //waits for signal to go back to P_GAME

    localparam  HH_1 = 5'b00001, //assuming only one switch is on at any given point
                HH_2 = 5'b00010, //for switches
                HH_3 = 5'b00100,
                HH_4 = 5'b01000,
                HH_5 = 5'b10000;

    localparam  HH_REST     = 3'b001, //for states
                HH_READY    = 3'b010,
                HH_HIT      = 3'b100;

    
    reg [2:0] curState, nextState;
    //reg [7:0] Xsize;            //upper bound of counter
    //reg [6:0] Ysize;
    reg [7:0] xProgress;        //counter
    reg [6:0] yProgress;

    wire [2:0] hhCol, splashCol, gSteadyCol;

    reg [15:0] counter;
	reg [14:0] address;
	
	reg [1:0] buffer;
	
	//reg [1:0] selector;
	/*
	select states:
	00 - outline (rest)
	01 - coloured in ('ready')
	10 - hit
	11 - bonus? (// counter)
	*/
	reg [4:0] stoHHSelect;

    //reg [1:0] loading; //counter for # of HH's drawn
/*
How this code aims to work (to simulate eric's code)

use 5 switches to simulate which hard hat is selected by Eric's code
use buttons to toggle what state each one should be in (state of each is stored in register)


use button 3 (left most) to initialize start of game (HH_HIT)

reset should re-draw start screen

INTEGRATION w. ERIC'S CODE:
each bit in the hh state refers to one hard hat on the screen
Assume that at the game start the input is all 0's

when one of the inputs goes to 1, draw that hard hat in whatever state the "hhState" is set to.
when it goes to 0, draw it in the rest state (no matter what)



game is rest

moves to plotHH if the value at the switches changes 
(process change in GAME and draw changes in P_HH_GAME)


*/

	
	splash s0(.address(address), .clock(clk), .data(3'b000), .wren(1'b0), .q(splashCol));    
	g_steady g0(.address(address), .clock(clk), .data(3'b000), .wren(1'b0), .q(gSteadyCol));  //pixels are offset by one pixel(same as assign statements)
	
	
    always@(*) begin 
        case(curState)
        P_RST: 
            nextState <= oDone ? RST : P_RST;
				//if(oDone) nextState <= RST;
        RST:
            nextState <= (startGame) ? W_LOADING : RST;
				//if(startGame) nextState <= W_LOADING;
        W_LOADING: 
            nextState <= (!startGame) ? P_GAME : W_LOADING;
				//if(!startGame) nextState <= P_GAME;
		  P_GAME:
			   nextState <= oDone ? GAME : P_GAME;
				//if(oDone) nextState <= GAME;
		  GAME: begin
            if(hhSelect != stoHHSelect) nextState <= P_HH_GAME;
			   else if (endGame) nextState <= GAME_OVER; //check if all 5 hard hats are selected
        end
		//W_GAME: //might remove this later when integrating with Eric's code;
		//	nextState <= (|hhState) ?  W_GAME: P_HH_GAME;
		  P_HH_GAME:
			   nextState <= oDone ? GAME : P_HH_GAME;
				//if(oDone) nextState <= GAME;
        GAME_OVER:
            nextState <= (counter == 0) ? P_RST : GAME_OVER;
				//if(counter == 0) nextState <= P_RST;
		  endcase
    end

	always@(posedge clk) begin
		if(iResetn) begin 
            curState <= P_RST;
            oX <= 0;
            oY <= 0;
			oDone <= 0;
			address <= 1;
            xProgress <= 0;
            yProgress <= 0;
				stoHHSelect <= 0;
				buffer <= 0;
			//Xsize <= X_SCREEN_PIXELS -1;
			//Ysize <= Y_SCREEN_PIXELS -1;
			counter <= CLOCK_FREQ;
			//loading <= 2'b11;
        end
		else begin
			curState <= nextState;
			
			case(curState)
			P_RST: begin  //memory code judraws box, only different is colour comes from memory
				oColour <= splashCol;
				//if(buffer == 2'b11) begin
				//buffer <= 0;
                address <= address +15'd1;
				if (!oDone) begin
                oPlot <= 1;  
                if (xProgress < X_SCREEN_PIXELS -1) begin
                    oX <= oX + 1; 
                    xProgress <= xProgress + 1;  
                end else begin
                //if (xProgress == Xsize) begin
                    oX <= oX - xProgress;  
                    xProgress <= 0; 
                    if (yProgress < Y_SCREEN_PIXELS -1) begin
                        oY <= oY + 1;  
                        yProgress <= yProgress + 1; 
                    end
                end
                if (xProgress == (X_SCREEN_PIXELS -1) && yProgress == (Y_SCREEN_PIXELS -1)) begin
                    oDone <= 1;  
                    oPlot <= 0;  
					//loading = loading + 1;
                    oX <= 0;
                    oY <= 0;
                    oX <= 0;
                    oY <= 0;
                    address <= 0;
                end
            end else begin
                oDone <= 1; 
            end
				//end else buffer <= buffer +1;
			end
			RST: address <= 0;//oDone <= 1'b1;//does anything happen here?
			W_LOADING: begin
				//Xsize <= X_HH -1;
				//Ysize <= Y_HH -1;
				//probably other shit
				//counter <= counter -1;
				//selector <= 2'b11; // (this should select a colourful one
                oDone <= 0;
                address <= 0;
                xProgress <= 0;
                yProgress <= 0;
			end
			P_GAME: begin
			//plot code that uses memory
                oColour <= gSteadyCol;
                address <= address +1;
				if (!oDone) begin
                oPlot <= 1;  
                if (xProgress < X_SCREEN_PIXELS -1) begin
                    oX <= oX + 1; 
                    xProgress <= xProgress + 1;  
                end else begin
                //if (xProgress == Xsize) begin
                    oX <= oX - xProgress;  
                    xProgress <= 0; 
                    if (yProgress < Y_SCREEN_PIXELS -1) begin
                        oY <= oY + 1;  
                        yProgress <= yProgress + 1; 
                    end
                end
                if (xProgress == (X_SCREEN_PIXELS -1) && yProgress == (Y_SCREEN_PIXELS -1)) begin
                    oDone <= 1;  
                    oPlot <= 0;  
					//loading = loading + 1;
                    oX <= 0;
                    oY <= 0;
                    address <= 0;
                end
            end else begin
                oDone <= 1; 
            end
			end
			GAME: begin
				oDone <= 0;//does anything acc happen in this state
				yProgress <= 0;
				counter <= CLOCK_FREQ;
				stoHHSelect <= hhSelect;
				case(hhSelect) //decoding hhSelect
				HH_1: begin  //(for now) assuming only one hh is selected at any given time
					oX <= X_1;
					oY <= Y_1;
				end
				HH_2: begin
					oX <= X_2;
					oY <= Y_2;
				end
				HH_3: begin
					oX <= X_3;
					oY <= Y_3;
				end
				HH_4: begin
					oX <= X_4;
					oY <= Y_4;
				end
				HH_5: begin
					oX <= X_5;
					oY <= Y_5;
				end
				endcase
			end
			//W_GAME: begin
			//	
			//end
			P_HH_GAME: begin
				//decode stoHHselect and hhstate
				//acc plot
                oColour <= hhCol; //colour not being set currectly
				//oColour <= splashCol;
                //address <= address +1;
				if (!oDone) begin
                oPlot <= 1;  
                if (xProgress < X_HH -1) begin
                    oX <= oX + 1; 
                    xProgress <= xProgress + 1;  
                end else begin
                //if (xProgress == Xsize) begin
                    oX <= oX - xProgress;  
                    xProgress <= 0; 
                    if (yProgress < Y_HH -1) begin
                        oY <= oY + 1;  
                        yProgress <= yProgress + 1; 
                    end
                end
                if (xProgress == (X_HH -1) && yProgress == (Y_HH -1)) begin
                    oDone <= 1;  
                    oPlot <= 0;  
					//loading = loading + 1;
                    oX <= 0;
                    oY <= 0;
                    oX <= 0;
                    oY <= 0;
                    address <= 1;
                end
				end
				end
            GAME_OVER: counter <= counter -1;
			endcase
		end
	end


endmodule


